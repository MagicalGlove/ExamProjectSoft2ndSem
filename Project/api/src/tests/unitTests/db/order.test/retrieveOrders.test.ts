import { AppDataSource } from '../../../../ormconfig.ts';
import * as orderAndFeedbackService from '../../../../monolithOrderAndFeedback/OrderAndFeedbackService.ts';
import * as orderAndFeedbackRepository from '../../../../monolithOrderAndFeedback/OrderAndFeedbackRepository.ts';
import { ObjectId } from 'mongodb';
import { getAllOrdersMockOrder1, getAllOrdersMockOrder2 } from '../../../mocks/orderMocksDB.ts';
import { Order } from '../../../../monolithOrderAndFeedback/Order.ts';

describe('Retrieve orders functions', () => {
    const orderRepository = AppDataSource.getMongoRepository(Order);

    beforeAll(async () => {
        await AppDataSource.initialize();
    });

    let dummyOrder2: Order | null;
    let dummyOrder1: Order | null;

    beforeEach(async () => {
        // Declare the variables once
        let customerID, restaurantID, address, totalPrice, orderItemList, timestamp;

        // Assign values from getAllOrdersMockOrder1
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder1);

        dummyOrder1 = await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );

        dummyOrder1 = {
            ...(dummyOrder1 as Order),
            status: 2,
            employeeID: new ObjectId('672df427f54107237ff75569'),
        };

        // Assign values from getAllOrdersMockOrder2
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder2);

        dummyOrder2 = await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );

        dummyOrder2 = {
            ...(dummyOrder2 as Order),
            status: 2,
            employeeID: new ObjectId('672df427f54107237ff75569'),
        };

        await orderRepository.save(dummyOrder1);
        await orderRepository.save(dummyOrder2);
    });

    afterEach(async () => {
        const repository = AppDataSource.getRepository(Order);
        await repository.delete({}); //Deletes all documents in the collection
    });

    afterAll(async () => {
        await AppDataSource.destroy();
    });

    it('should get all accepted orders', async () => {
        if (!dummyOrder1 || !dummyOrder2) throw new Error('An order was not created properly!');

        const orders = await orderAndFeedbackService.getAllAcceptedOrders();

        expect(orders).not.toBeNull();

        expect(orders).toEqual(
            expect.arrayContaining([
                expect.objectContaining({
                    _id: expect.any(Object), // If the ID is autogenerated
                    customerID: dummyOrder1.customerID,
                    restaurantID: dummyOrder1.restaurantID,
                    address: dummyOrder1.address,
                    totalPrice: dummyOrder1.totalPrice,
                    orderItemList: dummyOrder1.orderItemList,
                    timestamp: dummyOrder1.timestamp,
                }),
                expect.objectContaining({
                    _id: expect.any(Object),
                    customerID: dummyOrder2.customerID,
                    restaurantID: dummyOrder2.restaurantID,
                    address: dummyOrder2.address,
                    totalPrice: dummyOrder2.totalPrice,
                    orderItemList: dummyOrder2.orderItemList,
                    timestamp: dummyOrder2.timestamp,
                }),
            ])
        );
    });

    it('should handle errors and return null', async () => {
        jest.spyOn(orderRepository, 'find').mockRejectedValue(new Error('Database error'));

        const orders = await orderAndFeedbackRepository.GetAllAcceptedOrders();

        expect(orders).toBeNull();
        jest.restoreAllMocks();
    });

    it('should get all own orders', async () => {
        if (!dummyOrder1 || !dummyOrder2) throw new Error('An order was not created properly!');
        if (!dummyOrder1.employeeID) throw new Error('Order has no employeeID!');

        const orders = await orderAndFeedbackRepository.GetOwnOrders(dummyOrder1.employeeID?.toString(), 2);

        expect(orders).not.toBeNull();

        expect(orders).toEqual(
            expect.arrayContaining([
                expect.objectContaining({
                    _id: expect.any(Object), // If the ID is autogenerated
                    customerID: dummyOrder1.customerID,
                    restaurantID: dummyOrder1.restaurantID,
                    address: dummyOrder1.address,
                    totalPrice: dummyOrder1.totalPrice,
                    orderItemList: dummyOrder1.orderItemList,
                    timestamp: dummyOrder1.timestamp,
                }),
                expect.objectContaining({
                    _id: expect.any(Object),
                    customerID: dummyOrder2.customerID,
                    restaurantID: dummyOrder2.restaurantID,
                    address: dummyOrder2.address,
                    totalPrice: dummyOrder2.totalPrice,
                    orderItemList: dummyOrder2.orderItemList,
                    timestamp: dummyOrder2.timestamp,
                }),
            ])
        );
    });

    it('should fail to get all own orders because of wrong ID', async () => {
        if (!dummyOrder1 || !dummyOrder2) throw new Error('An order was not created properly!');
        if (!dummyOrder1.employeeID) throw new Error('Order has no employeeID!');

        await expect(orderAndFeedbackRepository.GetOwnOrders('wrongID', 2)).rejects.toThrow('Error retrieving orders');
    });

    it('should get all orders basesd on restaurant id', async () => {
        if (!dummyOrder1 || !dummyOrder2) throw new Error('An order was not created properly!');
        if (!dummyOrder1.employeeID) throw new Error('Order has no employeeID!');

        const orders = await orderAndFeedbackRepository.GetAllOrdersById('672de88ff54107237ff75565');

        expect(orders).not.toBeNull();

        expect(orders).toEqual(
            expect.arrayContaining([
                expect.objectContaining({
                    _id: expect.any(Object), // If the ID is autogenerated
                    customerID: dummyOrder1.customerID,
                    restaurantID: dummyOrder1.restaurantID,
                    address: dummyOrder1.address,
                    totalPrice: dummyOrder1.totalPrice,
                    orderItemList: dummyOrder1.orderItemList,
                    timestamp: dummyOrder1.timestamp,
                }),
                expect.objectContaining({
                    _id: expect.any(Object),
                    customerID: dummyOrder2.customerID,
                    restaurantID: dummyOrder2.restaurantID,
                    address: dummyOrder2.address,
                    totalPrice: dummyOrder2.totalPrice,
                    orderItemList: dummyOrder2.orderItemList,
                    timestamp: dummyOrder2.timestamp,
                }),
            ])
        );
    });

    it('should fail to get orders by restaurant id', async () => {
        if (!dummyOrder1 || !dummyOrder2) throw new Error('An order was not created properly!');
        if (!dummyOrder1.employeeID) throw new Error('Order has no employeeID!');

        const orders = await orderAndFeedbackRepository.GetAllOrdersById('wrongID');

        expect(orders).toBeNull();
    });
});
