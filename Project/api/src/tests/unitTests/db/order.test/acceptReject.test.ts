import { AppDataSource } from '../../../../ormconfig.ts';
import * as orderAndFeedbackService from '../../../../monolithOrderAndFeedback/OrderAndFeedbackService.ts';
import * as orderAndFeedbackRepository from '../../../../monolithOrderAndFeedback/OrderAndFeedbackRepository.ts';
import { getAllOrdersMockOrder1, getAllOrdersMockOrder2 } from '../../../mocks/orderMocksDB.ts';
import { Order } from '../../../../monolithOrderAndFeedback/Order.ts';

describe('Accept and reject order as restuarant', () => {
    beforeAll(async () => {
        await AppDataSource.initialize();
    });

    let dummyOrder: Order | null;

    beforeEach(async () => {
        // Declare the variables once
        let customerID, restaurantID, address, totalPrice, orderItemList, timestamp;

        // Assign values from getAllOrdersMockOrder1
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder1);

        dummyOrder = await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );

        // Assign values from getAllOrdersMockOrder2
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder2);

        await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );
    });

    afterEach(async () => {
        const repository = AppDataSource.getRepository(Order);
        await repository.delete({}); //Deletes all documents in the collection
    });

    afterAll(async () => {
        await AppDataSource.destroy();
    });

    it('should succesfully reject order as restaurant', async () => {
        if (!dummyOrder?._id) throw new Error('Order was not created!');

        const acceptedOrder = await orderAndFeedbackRepository.acceptRejectOrder(
            dummyOrder?._id.toString(),
            1,
            'Han har bestilt bearnaise pizza, ewww :vomit:'
        );

        expect(acceptedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(acceptedOrder).toEqual(
            expect.objectContaining({
                _id: expect.any(Object), // If the ID is autogenerated
                customerID: getAllOrdersMockOrder1.customerID,
                restaurantID: getAllOrdersMockOrder1.restaurantID,
                address: getAllOrdersMockOrder1.address,
                totalPrice: getAllOrdersMockOrder1.totalPrice,
                orderItemList: getAllOrdersMockOrder1.orderItemList,
                timestamp: getAllOrdersMockOrder1.timestamp,
                status: 1,
                rejectReason: 'Han har bestilt bearnaise pizza, ewww :vomit:',
            })
        );
    });

    it('should accept order', async () => {
        if (!dummyOrder?._id) throw new Error('Order was not created!');

        const acceptedOrder = await orderAndFeedbackRepository.acceptRejectOrder(dummyOrder?._id.toString(), 2, '');

        expect(acceptedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(acceptedOrder).toEqual(
            expect.objectContaining({
                _id: expect.any(Object), // If the ID is autogenerated
                customerID: getAllOrdersMockOrder1.customerID,
                restaurantID: getAllOrdersMockOrder1.restaurantID,
                address: getAllOrdersMockOrder1.address,
                totalPrice: getAllOrdersMockOrder1.totalPrice,
                orderItemList: getAllOrdersMockOrder1.orderItemList,
                timestamp: getAllOrdersMockOrder1.timestamp,
                status: 2,
            })
        );
    });
});
