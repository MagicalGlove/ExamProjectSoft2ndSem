import { AppDataSource } from '../../../../ormconfig.ts';
import * as orderAndFeedbackService from '../../../../monolithOrderAndFeedback/OrderAndFeedbackService.ts';
import * as orderAndFeedbackRepository from '../../../../monolithOrderAndFeedback/OrderAndFeedbackRepository.ts';
import { ObjectId } from 'mongodb';
import { getAllOrdersMockOrder1, getAllOrdersMockOrder2 } from '../../../mocks/orderMocksDB.ts';
import { Order } from '../../../../monolithOrderAndFeedback/Order.ts';

describe('calculate and complete order', () => {
    const orderRepository = AppDataSource.getMongoRepository(Order);

    beforeAll(async () => {
        await AppDataSource.initialize();
    });

    let dummyOrder: Order | null;

    beforeEach(async () => {
        // Declare the variables once
        let customerID, restaurantID, address, totalPrice, orderItemList, timestamp;

        // Assign values from getAllOrdersMockOrder1
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder1);

        dummyOrder = await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );

        // Assign values from getAllOrdersMockOrder2
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder2);

        await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );
    });

    afterEach(async () => {
        const repository = AppDataSource.getRepository(Order);
        await repository.delete({}); //Deletes all documents in the collection
    });

    afterAll(async () => {
        await AppDataSource.destroy();
    });

    it('should calculate and update correctly', async () => {
        if (!dummyOrder?._id) throw new Error('Order was not created!');

        const feedbackData = {
            foodRating: 5,
            overallRating: 4,
            deliveryRating: 3,
            orderId: dummyOrder._id,
        };

        const feedback = await orderAndFeedbackRepository.createFeedbackAndLinkOrder(feedbackData);

        dummyOrder = {
            ...(dummyOrder as Order),
            status: 3,
            employeeID: new ObjectId('672df427f54107237ff75569'),
            feedbackID: feedback._id,
        };

        const order = await orderRepository.save(dummyOrder);

        if (!order.employeeID) throw new Error('Order was not created!');

        const calculatedUpdatedOrder = await orderAndFeedbackRepository.calculateAndUpdateOrderPay(
            order?._id.toString()
        );

        expect(calculatedUpdatedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(calculatedUpdatedOrder).toEqual(
            expect.objectContaining({
                _id: expect.any(Object), // If the ID is autogenerated
                pay: expect.objectContaining({ totalPay: expect.any(Number) }),
                customerID: dummyOrder.customerID,
                restaurantID: dummyOrder.restaurantID,
                address: dummyOrder.address,
                totalPrice: dummyOrder.totalPrice,
                orderItemList: dummyOrder.orderItemList,
                timestamp: dummyOrder.timestamp,
                employeeID: dummyOrder.employeeID,
                status: 3,
            })
        );
    });

    it('should calculate and update with night bonus and speed bonus', async () => {
        if (!dummyOrder?._id) throw new Error('Order was not created!');

        const feedbackData = {
            foodRating: 5,
            overallRating: 4,
            deliveryRating: 3,
            orderId: dummyOrder._id,
        };

        const feedback = await orderAndFeedbackRepository.createFeedbackAndLinkOrder(feedbackData);

        dummyOrder = {
            ...(dummyOrder as Order),
            status: 3,
            employeeID: new ObjectId('672df427f54107237ff75569'),
            feedbackID: feedback._id,
            timestamp: (() => {
                const time = new Date();
                time.setHours(23, 30, 0, 0);
                return time;
            })(),
            pickUpDate: (() => {
                const time = new Date();
                time.setHours(23, 35, 0, 0);
                return time;
            })(),
            completionDate: (() => {
                const time = new Date();
                time.setHours(23, 45, 0, 0);
                return time;
            })(),
        };

        const order = await orderRepository.save(dummyOrder);

        if (!order.employeeID) throw new Error('Order was not created!');

        const calculatedUpdatedOrder = await orderAndFeedbackRepository.calculateAndUpdateOrderPay(
            order?._id.toString()
        );

        expect(calculatedUpdatedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(calculatedUpdatedOrder).toEqual(
            expect.objectContaining({
                _id: dummyOrder._id, // Adjusted for string ID
                customerID: dummyOrder.customerID,
                restaurantID: dummyOrder.restaurantID,
                address: dummyOrder.address,
                totalPrice: dummyOrder.totalPrice,
                orderItemList: dummyOrder.orderItemList,
                timestamp: dummyOrder.timestamp,
                pickUpDate: dummyOrder.pickUpDate, // Fixed field name
                completionDate: dummyOrder.completionDate, // Added field
                feedbackID: feedback._id, // Added field
                employeeID: dummyOrder.employeeID,
                status: 3,
            })
        );
    });

    it('should calculate and update with moderate delivery time bonus and max TOQmultiplier', async () => {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const mockOrders = Array.from({ length: 201 }, (_, index) => ({
            _id: new ObjectId(),
            customerID: new ObjectId(),
            restaurantID: new ObjectId(),
            employeeID: new ObjectId('672df427f54107237ff75569'), // Same `employeeID` for filtering
            status: 4,
            address: new ObjectId(),
            totalPrice: Math.random() * 100,
            orderItemList: Array.from({ length: Math.floor(Math.random() * 5) + 1 }, () => ({
                menuItemId: new ObjectId(),
                quantity: Math.floor(Math.random() * 5) + 1,
            })),
            feedbackID: new ObjectId(),
            timestamp: new Date(),
            pickUpDate: new Date(),
            completionDate: new Date(),
            pay: {
                baseAmount: Math.random() * 10,
                totalOrderQuantityMultiplier: Math.random() * 2,
                deliverySpeedMultiplier: Math.random() * 2,
                feedbackRatingMultiplier: Math.random(),
                orderPriceBonus: Math.random(),
                nightTimeBonus: Math.random(),
                totalPay: Math.random() * 100,
            },
            rejectReason: null,
        }));

        jest.spyOn(orderRepository, 'find').mockResolvedValue(mockOrders);

        if (!dummyOrder?._id) throw new Error('Order was not created!');

        const feedbackData = {
            foodRating: 5,
            overallRating: 4,
            deliveryRating: 3,
            orderId: dummyOrder._id,
        };

        const feedback = await orderAndFeedbackRepository.createFeedbackAndLinkOrder(feedbackData);

        dummyOrder = {
            ...(dummyOrder as Order),
            status: 3,
            employeeID: new ObjectId('672df427f54107237ff75569'),
            feedbackID: feedback._id,
            timestamp: (() => {
                const now = new Date();
                now.setHours(19, 30, 0, 0);
                return now;
            })(),
            pickUpDate: (() => {
                const now = new Date();
                now.setHours(20, 5, 0, 0);
                return now;
            })(),
            completionDate: (() => {
                const now = new Date();
                now.setHours(20, 45, 0, 0);
                return now;
            })(),
        };

        const order = await orderRepository.save(dummyOrder);

        if (!order.employeeID) throw new Error('Order was not created!');

        const calculatedUpdatedOrder = await orderAndFeedbackRepository.calculateAndUpdateOrderPay(
            order?._id.toString()
        );

        jest.restoreAllMocks();

        expect(calculatedUpdatedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(calculatedUpdatedOrder).toEqual(
            expect.objectContaining({
                _id: dummyOrder._id, // Adjusted for string ID
                customerID: dummyOrder.customerID,
                restaurantID: dummyOrder.restaurantID,
                address: dummyOrder.address,
                totalPrice: dummyOrder.totalPrice,
                orderItemList: dummyOrder.orderItemList,
                timestamp: dummyOrder.timestamp,
                pickUpDate: dummyOrder.pickUpDate, // Fixed field name
                completionDate: dummyOrder.completionDate, // Added field
                feedbackID: feedback._id, // Added field
                employeeID: dummyOrder.employeeID,
                status: 3,
            })
        );
    });

    it('should calculate and update with slow delivery time bonus', async () => {
        if (!dummyOrder?._id) throw new Error('Order was not created!');

        const feedbackData = {
            foodRating: 5,
            overallRating: 4,
            deliveryRating: 3,
            orderId: dummyOrder._id,
        };

        const feedback = await orderAndFeedbackRepository.createFeedbackAndLinkOrder(feedbackData);

        dummyOrder = {
            ...(dummyOrder as Order),
            status: 3,
            employeeID: new ObjectId('672df427f54107237ff75569'),
            feedbackID: feedback._id,
            timestamp: (() => {
                const now = new Date();
                now.setHours(19, 30, 0, 0);
                return now;
            })(),
            pickUpDate: (() => {
                const now = new Date();
                now.setHours(20, 5, 0, 0);
                return now;
            })(),
            completionDate: (() => {
                const now = new Date();
                now.setHours(20, 55, 0, 0);
                return now;
            })(),
        };

        const order = await orderRepository.save(dummyOrder);

        if (!order.employeeID) throw new Error('Order was not created!');

        const calculatedUpdatedOrder = await orderAndFeedbackRepository.calculateAndUpdateOrderPay(
            order?._id.toString()
        );

        expect(calculatedUpdatedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(calculatedUpdatedOrder).toEqual(
            expect.objectContaining({
                _id: dummyOrder._id, // Adjusted for string ID
                customerID: dummyOrder.customerID,
                restaurantID: dummyOrder.restaurantID,
                address: dummyOrder.address,
                totalPrice: dummyOrder.totalPrice,
                orderItemList: dummyOrder.orderItemList,
                timestamp: dummyOrder.timestamp,
                pickUpDate: dummyOrder.pickUpDate, // Fixed field name
                completionDate: dummyOrder.completionDate, // Added field
                feedbackID: feedback._id, // Added field
                employeeID: dummyOrder.employeeID,
                status: 3,
            })
        );
    });

    it('should fail to find order', async () => {
        jest.spyOn(orderRepository, 'findOne').mockResolvedValue(null);

        if (!dummyOrder?._id) throw new Error('Order was not created!');

        await expect(orderAndFeedbackRepository.calculateAndUpdateOrderPay(dummyOrder?._id.toString())).rejects.toThrow(
            `Order with ID ${dummyOrder?._id.toString()} not found`
        );

        jest.restoreAllMocks();
    });
});
