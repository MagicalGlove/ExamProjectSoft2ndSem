import { AppDataSource } from '../../../ormconfig.ts';
import * as orderAndFeedbackService from '../../../monolithOrderAndFeedback/OrderAndFeedbackService.ts';
import * as orderAndFeedbackRepository from '../../../monolithOrderAndFeedback/OrderAndFeedbackRepository.ts';
import { ObjectId } from 'mongodb';
import { getAllOrdersMockOrder1, getAllOrdersMockOrder2 } from '../../mocks/orderMocksDB.ts';
import { Order } from '../../../monolithOrderAndFeedback/Order.ts';
import { Feedback } from '../../../monolithOrderAndFeedback/Feedback.ts';

describe('Database Functionality for createFeedbackAndLinkOrder', () => {
    beforeAll(async () => {
        await AppDataSource.initialize();
    });

    beforeEach(async () => {
        // Declare the variables once
        let customerID, restaurantID, address, totalPrice, orderItemList, timestamp;

        // Assign values from getAllOrdersMockOrder1
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder1);

        await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );

        // Assign values from getAllOrdersMockOrder2
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder2);

        await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );
    });

    afterEach(async () => {
        const repository = AppDataSource.getRepository(Order);
        await repository.delete({}); //Deletes all documents in the collection
    });

    afterAll(async () => {
        await AppDataSource.destroy();
    });

    it('should create order', async () => {
        const mockOrder = {
            _id: new ObjectId('673de997fa60e0a917658708'),
            customerID: new ObjectId('672df427f54107237ff75565'),
            restaurantID: new ObjectId('672de88ff54107237ff75565'),
            address: new ObjectId('672df723f54107237ff75573'),
            totalPrice: 50,
            orderItemList: [
                {
                    menuItemId: new ObjectId('672de8c4f54107237ff75546'),
                    quantity: 2,
                },
                {
                    menuItemId: new ObjectId('672de8c4f54107237ff75547'),
                    quantity: 3,
                },
                {
                    menuItemId: new ObjectId('672de8c4f54107237ff75548'),
                    quantity: 1,
                },
            ],
            timestamp: new Date('2024-11-20T12:00:00.000Z'),
            employeeID: null,
            feedbackID: null,
        };

        const order = await orderAndFeedbackService.createOrder(
            mockOrder.customerID,
            mockOrder.restaurantID,
            mockOrder.orderItemList,
            mockOrder.address,
            mockOrder.totalPrice,
            mockOrder.timestamp
        );

        if (!order) {
            throw new Error('Order creation failed, cannot proceed with feedback creation');
        }

        const orderData = {
            _id: new ObjectId('673de997fa60e0a917658708'),
            customerID: new ObjectId('672df427f54107237ff75565'),
            restaurantID: new ObjectId('672de88ff54107237ff75565'),
            address: new ObjectId('672df723f54107237ff75573'),
            totalPrice: 50,
            orderItemList: [
                {
                    menuItemId: new ObjectId('672de8c4f54107237ff75546'),
                    quantity: 2,
                },
                {
                    menuItemId: new ObjectId('672de8c4f54107237ff75547'),
                    quantity: 3,
                },
                {
                    menuItemId: new ObjectId('672de8c4f54107237ff75548'),
                    quantity: 1,
                },
            ],
            timestamp: new Date('2024-11-20T12:00:00.000Z'),
            employeeID: null,
            feedbackID: null,
        };

        expect(order).not.toBeNull();
        expect(order.timestamp).toStrictEqual(orderData.timestamp);
        expect(order.totalPrice).toBe(orderData.totalPrice);
        expect(order.orderItemList).toStrictEqual(orderData.orderItemList);
    });

    it('should get all orders', async () => {
        const orders = await orderAndFeedbackService.getAllOrders();

        expect(orders).not.toBeNull();

        // Match only the necessary properties
        expect(orders).toEqual(
            expect.arrayContaining([
                expect.objectContaining({
                    _id: expect.any(Object), // If the ID is autogenerated
                    customerID: getAllOrdersMockOrder1.customerID,
                    restaurantID: getAllOrdersMockOrder1.restaurantID,
                    address: getAllOrdersMockOrder1.address,
                    totalPrice: getAllOrdersMockOrder1.totalPrice,
                    orderItemList: getAllOrdersMockOrder1.orderItemList,
                    timestamp: getAllOrdersMockOrder1.timestamp,
                }),
                expect.objectContaining({
                    _id: expect.any(Object),
                    customerID: getAllOrdersMockOrder2.customerID,
                    restaurantID: getAllOrdersMockOrder2.restaurantID,
                    address: getAllOrdersMockOrder2.address,
                    totalPrice: getAllOrdersMockOrder2.totalPrice,
                    orderItemList: getAllOrdersMockOrder2.orderItemList,
                    timestamp: getAllOrdersMockOrder2.timestamp,
                }),
            ])
        );
    });
});

describe('Retrieve orders functions', () => {
    beforeAll(async () => {
        await AppDataSource.initialize();
    });

    let dummyOrder2: Order | null;
    let dummyOrder1: Order | null;

    beforeEach(async () => {
        // Declare the variables once
        let customerID, restaurantID, address, totalPrice, orderItemList, timestamp;
        const orderRepository = AppDataSource.getMongoRepository(Order);

        // Assign values from getAllOrdersMockOrder1
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder1);

        dummyOrder1 = await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );

        dummyOrder1 = {
            ...(dummyOrder1 as Order),
            status: 2,
            employeeID: new ObjectId('672df427f54107237ff75569'),
        };

        // Assign values from getAllOrdersMockOrder2
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder2);

        dummyOrder2 = await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );

        dummyOrder2 = {
            ...(dummyOrder2 as Order),
            status: 2,
            employeeID: new ObjectId('672df427f54107237ff75569'),
        };

        await orderRepository.save(dummyOrder1);
        await orderRepository.save(dummyOrder2);
    });

    afterEach(async () => {
        const repository = AppDataSource.getRepository(Order);
        await repository.delete({}); //Deletes all documents in the collection
    });

    afterAll(async () => {
        await AppDataSource.destroy();
    });

    it('should get all accepted orders', async () => {
        if (!dummyOrder1 || !dummyOrder2) throw new Error('An order was not created properly!');

        const orders = await orderAndFeedbackRepository.GetAllAcceptedOrders();

        expect(orders).not.toBeNull();

        expect(orders).toEqual(
            expect.arrayContaining([
                expect.objectContaining({
                    _id: expect.any(Object), // If the ID is autogenerated
                    customerID: dummyOrder1.customerID,
                    restaurantID: dummyOrder1.restaurantID,
                    address: dummyOrder1.address,
                    totalPrice: dummyOrder1.totalPrice,
                    orderItemList: dummyOrder1.orderItemList,
                    timestamp: dummyOrder1.timestamp,
                }),
                expect.objectContaining({
                    _id: expect.any(Object),
                    customerID: dummyOrder2.customerID,
                    restaurantID: dummyOrder2.restaurantID,
                    address: dummyOrder2.address,
                    totalPrice: dummyOrder2.totalPrice,
                    orderItemList: dummyOrder2.orderItemList,
                    timestamp: dummyOrder2.timestamp,
                }),
            ])
        );
    });

    it('should get all own orders', async () => {
        if (!dummyOrder1 || !dummyOrder2) throw new Error('An order was not created properly!');
        if (!dummyOrder1.employeeID) throw new Error('Order has no employeeID!');

        const orders = await orderAndFeedbackRepository.GetOwnOrders(dummyOrder1.employeeID?.toString(), 2);

        expect(orders).not.toBeNull();

        expect(orders).toEqual(
            expect.arrayContaining([
                expect.objectContaining({
                    _id: expect.any(Object), // If the ID is autogenerated
                    customerID: dummyOrder1.customerID,
                    restaurantID: dummyOrder1.restaurantID,
                    address: dummyOrder1.address,
                    totalPrice: dummyOrder1.totalPrice,
                    orderItemList: dummyOrder1.orderItemList,
                    timestamp: dummyOrder1.timestamp,
                }),
                expect.objectContaining({
                    _id: expect.any(Object),
                    customerID: dummyOrder2.customerID,
                    restaurantID: dummyOrder2.restaurantID,
                    address: dummyOrder2.address,
                    totalPrice: dummyOrder2.totalPrice,
                    orderItemList: dummyOrder2.orderItemList,
                    timestamp: dummyOrder2.timestamp,
                }),
            ])
        );
    });

    it('should fail to get all own orders because of wrong ID', async () => {
        if (!dummyOrder1 || !dummyOrder2) throw new Error('An order was not created properly!');
        if (!dummyOrder1.employeeID) throw new Error('Order has no employeeID!');

        await expect(orderAndFeedbackRepository.GetOwnOrders('wrongID', 2)).rejects.toThrow('Error retrieving orders');
    });

    it('should get all orders basesd on restaurant id', async () => {
        if (!dummyOrder1 || !dummyOrder2) throw new Error('An order was not created properly!');
        if (!dummyOrder1.employeeID) throw new Error('Order has no employeeID!');

        const orders = await orderAndFeedbackRepository.GetAllOrdersById('672de88ff54107237ff75565');

        expect(orders).not.toBeNull();

        expect(orders).toEqual(
            expect.arrayContaining([
                expect.objectContaining({
                    _id: expect.any(Object), // If the ID is autogenerated
                    customerID: dummyOrder1.customerID,
                    restaurantID: dummyOrder1.restaurantID,
                    address: dummyOrder1.address,
                    totalPrice: dummyOrder1.totalPrice,
                    orderItemList: dummyOrder1.orderItemList,
                    timestamp: dummyOrder1.timestamp,
                }),
                expect.objectContaining({
                    _id: expect.any(Object),
                    customerID: dummyOrder2.customerID,
                    restaurantID: dummyOrder2.restaurantID,
                    address: dummyOrder2.address,
                    totalPrice: dummyOrder2.totalPrice,
                    orderItemList: dummyOrder2.orderItemList,
                    timestamp: dummyOrder2.timestamp,
                }),
            ])
        );
    });

    it('should fail to get orders by restaurant id', async () => {
        if (!dummyOrder1 || !dummyOrder2) throw new Error('An order was not created properly!');
        if (!dummyOrder1.employeeID) throw new Error('Order has no employeeID!');

        const orders = await orderAndFeedbackRepository.GetAllOrdersById('wrongID');

        expect(orders).toBeNull();
    });
});

describe('Accept and reject order as restuarant', () => {
    beforeAll(async () => {
        await AppDataSource.initialize();
    });

    let dummyOrder: Order | null;

    beforeEach(async () => {
        // Declare the variables once
        let customerID, restaurantID, address, totalPrice, orderItemList, timestamp;

        // Assign values from getAllOrdersMockOrder1
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder1);

        dummyOrder = await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );

        // Assign values from getAllOrdersMockOrder2
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder2);

        await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );
    });

    afterEach(async () => {
        const repository = AppDataSource.getRepository(Order);
        await repository.delete({}); //Deletes all documents in the collection
    });

    afterAll(async () => {
        await AppDataSource.destroy();
    });

    it('should accept order as restaurant', async () => {
        if (!dummyOrder?._id) throw new Error('Order was not created!');

        const acceptedOrder = await orderAndFeedbackRepository.acceptRejectOrder(
            dummyOrder?._id.toString(),
            1,
            'Han har bestilt bearnaise pizza, ewww :vomit:'
        );

        expect(acceptedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(acceptedOrder).toEqual(
            expect.objectContaining({
                _id: expect.any(Object), // If the ID is autogenerated
                customerID: getAllOrdersMockOrder1.customerID,
                restaurantID: getAllOrdersMockOrder1.restaurantID,
                address: getAllOrdersMockOrder1.address,
                totalPrice: getAllOrdersMockOrder1.totalPrice,
                orderItemList: getAllOrdersMockOrder1.orderItemList,
                timestamp: getAllOrdersMockOrder1.timestamp,
                status: 1,
                rejectReason: 'Han har bestilt bearnaise pizza, ewww :vomit:',
            })
        );
    });

    it('should reject order', async () => {
        if (!dummyOrder?._id) throw new Error('Order was not created!');

        const acceptedOrder = await orderAndFeedbackRepository.acceptRejectOrder(dummyOrder?._id.toString(), 2, '');

        expect(acceptedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(acceptedOrder).toEqual(
            expect.objectContaining({
                _id: expect.any(Object), // If the ID is autogenerated
                customerID: getAllOrdersMockOrder1.customerID,
                restaurantID: getAllOrdersMockOrder1.restaurantID,
                address: getAllOrdersMockOrder1.address,
                totalPrice: getAllOrdersMockOrder1.totalPrice,
                orderItemList: getAllOrdersMockOrder1.orderItemList,
                timestamp: getAllOrdersMockOrder1.timestamp,
                status: 2,
            })
        );
    });
});

describe('accept/complete order as delivery driver', () => {
    beforeAll(async () => {
        await AppDataSource.initialize();
    });

    let dummyOrder: Order | null;

    beforeEach(async () => {
        // Declare the variables once
        let customerID, restaurantID, address, totalPrice, orderItemList, timestamp;

        // Assign values from getAllOrdersMockOrder1
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder1);

        dummyOrder = await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );

        // Assign values from getAllOrdersMockOrder2
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder2);

        await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );
    });

    afterEach(async () => {
        const repository = AppDataSource.getRepository(Order);
        await repository.delete({}); //Deletes all documents in the collection
    });

    afterAll(async () => {
        await AppDataSource.destroy();
    });

    it('should accept order as delivery', async () => {
        const orderRepository = AppDataSource.getMongoRepository(Order);
        dummyOrder = {
            ...(dummyOrder as Order),
            status: 2,
            employeeID: new ObjectId('672df427f54107237ff75569'),
        };

        if (!dummyOrder?._id || !dummyOrder.employeeID) throw new Error('Order was not created!');

        await orderRepository.save(dummyOrder);

        const acceptedOrder = await orderAndFeedbackRepository.acceptOrderAsDelivery(
            dummyOrder?._id.toString(),
            dummyOrder.employeeID.toString()
        );

        expect(acceptedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(acceptedOrder).toEqual(
            expect.objectContaining({
                _id: expect.any(Object), // If the ID is autogenerated
                customerID: dummyOrder.customerID,
                restaurantID: dummyOrder.restaurantID,
                address: dummyOrder.address,
                totalPrice: dummyOrder.totalPrice,
                orderItemList: dummyOrder.orderItemList,
                timestamp: dummyOrder.timestamp,
                employeeID: dummyOrder.employeeID,
                status: 3,
            })
        );
    });

    it('complete order as delivery', async () => {
        const orderRepository = AppDataSource.getMongoRepository(Order);
        dummyOrder = {
            ...(dummyOrder as Order),
            status: 3,
            employeeID: new ObjectId('672df427f54107237ff75569'),
        };

        if (!dummyOrder?._id || !dummyOrder.employeeID) throw new Error('Order was not created!');

        await orderRepository.save(dummyOrder);

        const acceptedOrder = await orderAndFeedbackRepository.completeOrderAsDelivery(dummyOrder?._id.toString());

        expect(acceptedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(acceptedOrder).toEqual(
            expect.objectContaining({
                _id: expect.any(Object), // If the ID is autogenerated
                customerID: dummyOrder.customerID,
                restaurantID: dummyOrder.restaurantID,
                address: dummyOrder.address,
                totalPrice: dummyOrder.totalPrice,
                orderItemList: dummyOrder.orderItemList,
                timestamp: dummyOrder.timestamp,
                employeeID: dummyOrder.employeeID,
                status: 4,
            })
        );
    });
});
describe('calculate and complete order', () => {
    beforeAll(async () => {
        await AppDataSource.initialize();
    });

    let dummyOrder: Order | null;

    beforeEach(async () => {
        // Declare the variables once
        let customerID, restaurantID, address, totalPrice, orderItemList, timestamp;

        // Assign values from getAllOrdersMockOrder1
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder1);

        dummyOrder = await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );

        // Assign values from getAllOrdersMockOrder2
        ({ customerID, restaurantID, orderItemList, address, totalPrice, timestamp } = getAllOrdersMockOrder2);

        await orderAndFeedbackService.createOrder(
            customerID,
            restaurantID,
            orderItemList,
            address,
            totalPrice,
            timestamp
        );
    });

    afterEach(async () => {
        const repository = AppDataSource.getRepository(Order);
        await repository.delete({}); //Deletes all documents in the collection
    });

    afterAll(async () => {
        await AppDataSource.destroy();
    });

    it('should calculate and update correctly', async () => {
        const orderRepository = AppDataSource.getMongoRepository(Order);

        if (!dummyOrder?._id) throw new Error('Order was not created!');

        const feedbackData = {
            foodRating: 5,
            overallRating: 4,
            deliveryRating: 3,
            orderId: dummyOrder._id,
        };

        const feedback = await orderAndFeedbackRepository.createFeedbackAndLinkOrder(feedbackData);

        dummyOrder = {
            ...(dummyOrder as Order),
            status: 3,
            employeeID: new ObjectId('672df427f54107237ff75569'),
            feedbackID: feedback._id,
        };

        const order = await orderRepository.save(dummyOrder);

        if (!order.employeeID) throw new Error('Order was not created!');

        const calculatedUpdatedOrder = await orderAndFeedbackRepository.calculateAndUpdateOrderPay(
            order?._id.toString()
        );

        expect(calculatedUpdatedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(calculatedUpdatedOrder).toEqual(
            expect.objectContaining({
                _id: expect.any(Object), // If the ID is autogenerated
                pay: expect.any(Object),
                customerID: dummyOrder.customerID,
                restaurantID: dummyOrder.restaurantID,
                address: dummyOrder.address,
                totalPrice: dummyOrder.totalPrice,
                orderItemList: dummyOrder.orderItemList,
                timestamp: dummyOrder.timestamp,
                employeeID: dummyOrder.employeeID,
                status: 3,
            })
        );
    });

    it('should calculate and update with night bonus and speed bonus', async () => {
        const orderRepository = AppDataSource.getMongoRepository(Order);

        if (!dummyOrder?._id) throw new Error('Order was not created!');

        const feedbackData = {
            foodRating: 5,
            overallRating: 4,
            deliveryRating: 3,
            orderId: dummyOrder._id,
        };

        const feedback = await orderAndFeedbackRepository.createFeedbackAndLinkOrder(feedbackData);

        dummyOrder = {
            ...(dummyOrder as Order),
            status: 3,
            employeeID: new ObjectId('672df427f54107237ff75569'),
            feedbackID: feedback._id,
            timestamp: (() => {
                const now = new Date();
                now.setHours(23, 30, 0, 0); // Set to 11:30 PM
                return now;
            })(),
            pickUpDate: (() => {
                const now = new Date();
                now.setHours(23, 35, 0, 0); // Set to 11:30 PM
                return now;
            })(),
            completionDate: (() => {
                const now = new Date();
                now.setHours(23, 45, 0, 0); // Set to 11:30 PM
                return now;
            })(),
        };

        const order = await orderRepository.save(dummyOrder);

        if (!order.employeeID) throw new Error('Order was not created!');

        const calculatedUpdatedOrder = await orderAndFeedbackRepository.calculateAndUpdateOrderPay(
            order?._id.toString()
        );

        expect(calculatedUpdatedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(calculatedUpdatedOrder).toEqual(
            expect.objectContaining({
                _id: dummyOrder._id, // Adjusted for string ID
                customerID: dummyOrder.customerID,
                restaurantID: dummyOrder.restaurantID,
                address: dummyOrder.address,
                totalPrice: dummyOrder.totalPrice,
                orderItemList: dummyOrder.orderItemList,
                timestamp: dummyOrder.timestamp,
                pickUpDate: dummyOrder.pickUpDate, // Fixed field name
                completionDate: dummyOrder.completionDate, // Added field
                feedbackID: feedback._id, // Added field
                employeeID: dummyOrder.employeeID,
                status: 3,
            })
        );
    });

    it('should calculate and update with moderate delivery time bonus', async () => {
        const orderRepository = AppDataSource.getMongoRepository(Order);

        if (!dummyOrder?._id) throw new Error('Order was not created!');

        const feedbackData = {
            foodRating: 5,
            overallRating: 4,
            deliveryRating: 3,
            orderId: dummyOrder._id,
        };

        const feedback = await orderAndFeedbackRepository.createFeedbackAndLinkOrder(feedbackData);

        dummyOrder = {
            ...(dummyOrder as Order),
            status: 3,
            employeeID: new ObjectId('672df427f54107237ff75569'),
            feedbackID: feedback._id,
            timestamp: (() => {
                const now = new Date();
                now.setHours(19, 30, 0, 0); // Set to 11:30 PM
                return now;
            })(),
            pickUpDate: (() => {
                const now = new Date();
                now.setHours(20, 5, 0, 0); // Set to 11:30 PM
                return now;
            })(),
            completionDate: (() => {
                const now = new Date();
                now.setHours(20, 45, 0, 0); // Set to 11:30 PM
                return now;
            })(),
        };

        const order = await orderRepository.save(dummyOrder);

        if (!order.employeeID) throw new Error('Order was not created!');

        const calculatedUpdatedOrder = await orderAndFeedbackRepository.calculateAndUpdateOrderPay(
            order?._id.toString()
        );

        expect(calculatedUpdatedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(calculatedUpdatedOrder).toEqual(
            expect.objectContaining({
                _id: dummyOrder._id, // Adjusted for string ID
                customerID: dummyOrder.customerID,
                restaurantID: dummyOrder.restaurantID,
                address: dummyOrder.address,
                totalPrice: dummyOrder.totalPrice,
                orderItemList: dummyOrder.orderItemList,
                timestamp: dummyOrder.timestamp,
                pickUpDate: dummyOrder.pickUpDate, // Fixed field name
                completionDate: dummyOrder.completionDate, // Added field
                feedbackID: feedback._id, // Added field
                employeeID: dummyOrder.employeeID,
                status: 3,
            })
        );
    });

    it('should calculate and update with slow delivery time bonus', async () => {
        const orderRepository = AppDataSource.getMongoRepository(Order);

        if (!dummyOrder?._id) throw new Error('Order was not created!');

        const feedbackData = {
            foodRating: 5,
            overallRating: 4,
            deliveryRating: 3,
            orderId: dummyOrder._id,
        };

        const feedback = await orderAndFeedbackRepository.createFeedbackAndLinkOrder(feedbackData);

        dummyOrder = {
            ...(dummyOrder as Order),
            status: 3,
            employeeID: new ObjectId('672df427f54107237ff75569'),
            feedbackID: feedback._id,
            timestamp: (() => {
                const now = new Date();
                now.setHours(19, 30, 0, 0); // Set to 11:30 PM
                return now;
            })(),
            pickUpDate: (() => {
                const now = new Date();
                now.setHours(20, 5, 0, 0); // Set to 11:30 PM
                return now;
            })(),
            completionDate: (() => {
                const now = new Date();
                now.setHours(20, 55, 0, 0); // Set to 11:30 PM
                return now;
            })(),
        };

        const order = await orderRepository.save(dummyOrder);

        if (!order.employeeID) throw new Error('Order was not created!');

        const calculatedUpdatedOrder = await orderAndFeedbackRepository.calculateAndUpdateOrderPay(
            order?._id.toString()
        );

        expect(calculatedUpdatedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(calculatedUpdatedOrder).toEqual(
            expect.objectContaining({
                _id: dummyOrder._id, // Adjusted for string ID
                customerID: dummyOrder.customerID,
                restaurantID: dummyOrder.restaurantID,
                address: dummyOrder.address,
                totalPrice: dummyOrder.totalPrice,
                orderItemList: dummyOrder.orderItemList,
                timestamp: dummyOrder.timestamp,
                pickUpDate: dummyOrder.pickUpDate, // Fixed field name
                completionDate: dummyOrder.completionDate, // Added field
                feedbackID: feedback._id, // Added field
                employeeID: dummyOrder.employeeID,
                status: 3,
            })
        );
    });

    it('should fail to get order because of wrong ID', async () => {
        const wrongID = '672df427f54107237ff75569';
        await expect(orderAndFeedbackRepository.calculateAndUpdateOrderPay(wrongID)).rejects.toThrow(
            `Order with ID ${wrongID} not found`
        );
    });
});
