import { AppDataSource } from '../../../../ormconfig.ts';
import * as orderAndFeedbackRepository from '../../../../monolithOrderAndFeedback/OrderAndFeedbackRepository.ts';
import { ObjectId } from 'mongodb';
import { Order } from '../../../../monolithOrderAndFeedback/Order.ts';
import { createOrders } from '../../../utilities.ts';
import { mockOrder } from '../../../mocks/orderMocksDB.ts';
jest.mock('../../../../adapters/messaging');
jest.mock('../../../../adapters/kafkaAdapter');
describe('accept/complete order as delivery driver', () => {
    const orderRepository = AppDataSource.getMongoRepository(Order);

    beforeAll(async () => {
        await AppDataSource.initialize();
    });

    let dummyOrder: Order | null;
    let getOrder: () => Order | null;

    beforeEach(async () => {
        ({ getOrder } = await createOrders());
    });
    afterEach(async () => {
        const repository = AppDataSource.getRepository(Order);
        await repository.delete({}); //Deletes all documents in the collection
    });

    afterAll(async () => {
        await AppDataSource.destroy();
    });

    it('should accept order as delivery', async () => {
        dummyOrder = getOrder();

        dummyOrder = {
            ...(dummyOrder as Order),
            status: 2,
            employeeID: new ObjectId('672df427f54107237ff75569'),
        };

        if (!dummyOrder?._id || !dummyOrder.employeeID)
            throw new Error('Order was not created!');

        await orderRepository.save(dummyOrder);

        const acceptedOrder =
            await orderAndFeedbackRepository.acceptOrderAsDelivery(
                dummyOrder?._id.toString(),
                dummyOrder.employeeID.toString()
            );

        expect(acceptedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(acceptedOrder).toEqual(
            expect.objectContaining({
                _id: expect.any(Object), // If the ID is autogenerated
                customerID: dummyOrder.customerID,
                restaurantID: dummyOrder.restaurantID,
                address: dummyOrder.address,
                totalPrice: dummyOrder.totalPrice,
                orderItemList: dummyOrder.orderItemList,
                timestamp: dummyOrder.timestamp,
                employeeID: dummyOrder.employeeID,
                status: 3,
            })
        );
    });

    it('should fail to accept order because there is a reject reason, but not status 1', async () => {
        await expect(
            orderAndFeedbackRepository.acceptRejectOrder(
                'randomID',
                3,
                'This reason is not allowed because status is not 1'
            )
        ).rejects.toThrow(
            'There can only be a reason for rejecting, if status is set to 1, aka reject'
        );
    });

    it('should fail to accept order because status not between 0 and 4', async () => {
        await expect(
            orderAndFeedbackRepository.acceptRejectOrder('randomID', 9)
        ).rejects.toThrow('Status must be between between 0 and 4, inclusive');
    });

    it('should fail to accept order because of wrong ID', async () => {
        await expect(
            orderAndFeedbackRepository.acceptRejectOrder(
                '672df427f54107237ff75561',
                3
            )
        ).rejects.toThrow('Order with ID 672df427f54107237ff75561 not found');
    });

    it('complete order as delivery', async () => {
        dummyOrder = getOrder();

        dummyOrder = {
            ...(dummyOrder as Order),
            status: 3,
            employeeID: new ObjectId('672df427f54107237ff75569'),
        };

        if (!dummyOrder?._id || !dummyOrder.employeeID)
            throw new Error('Order was not created!');

        await orderRepository.save(dummyOrder);

        const acceptedOrder =
            await orderAndFeedbackRepository.completeOrderAsDelivery(
                dummyOrder?._id.toString()
            );

        expect(acceptedOrder).not.toBeNull();

        // Match only the necessary properties
        expect(acceptedOrder).toEqual(
            expect.objectContaining({
                _id: expect.any(Object), // If the ID is autogenerated
                customerID: dummyOrder.customerID,
                restaurantID: dummyOrder.restaurantID,
                address: dummyOrder.address,
                totalPrice: dummyOrder.totalPrice,
                orderItemList: dummyOrder.orderItemList,
                timestamp: dummyOrder.timestamp,
                employeeID: dummyOrder.employeeID,
                status: 4,
            })
        );
    });

    it('fail to complete order because no order found', async () => {
        dummyOrder = getOrder();

        const findOneOrderSpy = jest
            .spyOn(orderRepository, 'findOne')
            .mockResolvedValue(null);

        dummyOrder = {
            ...(dummyOrder as Order),
            status: 2,
            employeeID: new ObjectId('672df427f54107237ff75569'),
        };

        if (!dummyOrder?._id || !dummyOrder.employeeID)
            throw new Error('Order was not created!');

        await orderRepository.save(dummyOrder);

        await expect(
            orderAndFeedbackRepository.acceptOrderAsDelivery(
                dummyOrder?._id.toString(),
                dummyOrder?.employeeID.toString()
            )
        ).rejects.toThrow(
            `Order with ID ${dummyOrder?._id.toString()} not found`
        );

        findOneOrderSpy.mockRestore();
    });

    it('should fail to accept order because of no order ID', async () => {
        dummyOrder = getOrder();

        const findOneOrderSpy = jest
            .spyOn(orderRepository, 'findOne')
            .mockResolvedValue(null);

        dummyOrder = {
            ...(dummyOrder as Order),
            status: 4,
            employeeID: new ObjectId('672df427f54107237ff75569'),
        };

        if (!dummyOrder?._id || !dummyOrder.employeeID)
            throw new Error('Order was not created!');

        await expect(
            orderAndFeedbackRepository.acceptOrderAsDelivery(
                '672df427f54107237ff75561',
                dummyOrder.employeeID?.toString()
            )
        ).rejects.toThrow('Order with ID 672df427f54107237ff75561 not found');

        findOneOrderSpy.mockRestore();
    });

    it('fail to complete order because status is not 2', async () => {
        dummyOrder = getOrder();

        dummyOrder = {
            ...(dummyOrder as Order),
            status: 4,
            employeeID: new ObjectId('672df427f54107237ff75569'),
        };

        if (!dummyOrder?._id || !dummyOrder.employeeID)
            throw new Error('Order was not created!');

        await orderRepository.save(dummyOrder);

        await expect(
            orderAndFeedbackRepository.acceptOrderAsDelivery(
                dummyOrder?._id.toString(),
                dummyOrder?.employeeID.toString()
            )
        ).rejects.toThrow(`Order is not at pick up stage`);
    });

    it('complete order fail because status is not 2', async () => {
        dummyOrder = getOrder();

        const findOneOrderSpy = jest
            .spyOn(orderRepository, 'findOne')
            .mockResolvedValue(null);

        if (!dummyOrder?._id) throw new Error('Order was not created!');

        await expect(
            orderAndFeedbackRepository.completeOrderAsDelivery(
                dummyOrder?._id.toString()
            )
        ).rejects.toThrow(`Order with ID ${dummyOrder?._id} not found`);

        findOneOrderSpy.mockRestore();
    });

    it('complete order fail because wrong order status', async () => {
        dummyOrder = getOrder();

        if (!dummyOrder?._id) throw new Error('Order was not created!');

        const findOneOrderSpy = jest
            .spyOn(orderRepository, 'findOne')
            .mockResolvedValue({ ...mockOrder, _id: dummyOrder._id });

        await expect(
            orderAndFeedbackRepository.completeOrderAsDelivery(
                dummyOrder?._id.toString()
            )
        ).rejects.toThrow('Order is not ready to be completed');

        findOneOrderSpy.mockRestore();
    });
});
